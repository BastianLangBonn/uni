function [ fitness, energy, power, speed, command ] = evaluateOnTrack( individual, p)
%EVALUATEONTRACK Summary of this function goes here
%   Detailed explanation goes here
    % Calculate Maximum Energy Consumption
    
    fitness = 0;
    wMat = individual.pheno.wMat;
    aMat = individual.pheno.aMat;
    track = p.track;
    slope = p.slope;
    desiredTime = p.desiredTime;
    
    energy = 0;
    speed = 0;
    command = 0;
    time = 0;
    fail = false;
    
    %State:
    % 1: time
    % 2: location
    % 3: speed
    % 4: power
    % 5: command
    % 6: slope
    
    state(1) = 0;
    state(2) = 0;
    state(3) = 1.5;
    state(4) = 0;   
   
    
    while state(2) < length(track) - 130 && ~fail
        pos = floor(state(2))+1;
        elevations = track(pos) - track(pos+[1 2 4 8 16 32 64 128]); 
        state(6) = slope(pos);
        
        % compute desired velocity
        timeLeft = desiredTime - state(1);
        distanceRemaining = length(track) - state(2);
        desiredVelocity = distanceRemaining / timeLeft;
        
        % Scale values
        scaledSpeed = tanh(state(3));
        scaledPower = tanh(state(4));
        scaledElevations = tanh(elevations);
        
        input = [scaledSpeed, scaledPower, scaledElevations]; 
        
        % Use scaled values for command computation
        output = FFNet(wMat,aMat,input,p);
        state(5) = output;
        
        % Use command and state to compute state for next timestep
        state = computeNextTimeStep(state);
        
        % Check new state
        if state(1) > desiredTime
            fail = true;
            disp('Took too long');
            break;
        end
        
        if floor(tstate(2))+1 == pos
            disp('Not moving!');
            fail = true;
            break;
        end;
        
        if state(3) < 1
           disp('Moving  
        end
        
        time(end+1) = state(:,1);
        speed(end+1) = state(:,3);    
        energy(end+1) = state(:,4);    
        command(end+1) = state(:,5);
        
    end
    
    



end

